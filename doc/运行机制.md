# Vue内部运行机制

开局一张图，从new Vue创建一个Vue实例开始，到DOM出现在浏览器上，vue内部所做的事情

![](../static/机制.png)

## 简单示例

我们先不使用`template`

```
const options = {
  render(h) {
    return h('p', [
      this.num,
      h('button', {on: { click: this.add }}, 'add')
    ])
  },

  data: {
    num: 0
  },

  methods: {
    add() {
      this.add += 1
    }
  }
}

new Vue(options).$mount('#app')
```

## _init

首先一个Vue实例的初始化，需要执行`_init`方法，代码有精简

```
Vue.prototype._init = function (options?: Object) {
  const vm: Component = this

  // 用来避免Vue实例被observed
  vm._isVue = true

  // 组件场景下合并配置
  if (options && options._isComponent) {
    initInternalComponent(vm, options)
  }
  // 非组组件场景下合并配置
  else {
    // vm.constructor === Vue. JS基础知识
    vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm)
  }

  vm._self = vm

  // 建立组件父子关系、$root、$refs、_watcher、初始化实例生命周期状态等
  initLifecycle(vm)

  // 注册组件事件 e.g. <componentA @notify="xxx"></componentA>
  initEvents(vm)

  // 初始化插槽、定义vm._c、vm.$createElement方法
  initRender(vm)

  // 调用beforeCreate生命周期钩子
  callHook(vm, 'beforeCreate')

  initInjections(vm) // resolve injections before data/props

  // 1、初始化props
  // 2、初始化methods
  // 3、初始化data
  // 4、初始化computed
  // 5、初始化watch
  initState(vm)

  initProvide(vm) // resolve provide after data/props
  // 调用created生命周期钩子
  callHook(vm, 'created')

  // 如果options中配置了el属性，直接将实例挂载到el所映射的DOM节点上
  // 否则需要手动执行vm.$mount(el)
  // e.g. new ({data: {a: 1}}).$mount('#app')
  if (vm.$options.el) {
    vm.$mount(vm.$options.el)
  }
}
```
可以看出`_init`方法主要做了如下事情:

* 合并配置
* 初始化生命周期
* 初始化事件
* 初始化render
* 初始化数据

其中初始化数据就是将数据变成响应式，也就是`initState`方法，我们重点关注下

## initData

`initState`源码如下，代码有精简

```
export function initState (vm: Component) {
  const opts = vm.$options

  initProps(vm, opts.props)
  initMethods(vm, opts.methods)
  initData(vm)
  initComputed(vm, opts.computed)
  initWatch(vm, opts.watch)
}
```

`initState`方法对`props`、`methods`、`data`、`computed`、`watch`进行初始化

抛开其他不谈，我们的例子中options只有`data`， 我们看`initData`。

```
function initData (vm: Component) {
  let data = vm.$options.data
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {}

  const keys = Object.keys(data)
  let i = keys.length
  while (i--) {
    const key = keys[i]
    proxy(vm, `_data`, key)
  }

  observe(data, true)
}
```

可以看出`initData`方法，先去获取`options`中的`data`。

⚠️ vue组件的`data`必须是个`function`，是为了确保一个组件被复用多次的时候，其中一个data的改变不会影响到其他复用的组件的data，使用函数作用域封闭了data

拿到data对象后，将访问`vm.xx` 代理到了 `vm._data.xxx`

然后调用`observe`方法，顾名思义，观察data对象，使其变成响应式

## observe

`observe`代码如下

```
function observe (value, asRootData) {
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  }
  else if ( shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue ) {
    ob = new Observer(value);
  }

  return ob
}
```

`Observer`代码如下

```
var Observer = function Observer (value) {
  this.value = value;

  def(value, '__ob__', this);

  // 数组
  if (Array.isArray(value)) {
    this.observeArray(value);
  }
  // 对象
  else {
    this.walk(value);
  }
};

Observer.prototype.walk = function walk (obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive(obj, keys[i]);
  }
};

Observer.prototype.observeArray = function observeArray (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

```

